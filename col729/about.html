<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252"><title>COL729 : Compiler Optimizations : About</title>
</head><body><h1><font color="blue">COL729 : Compiler Optimizations : About</font></h1>

This page provides a summary of the intended course contents and material for prospective students of the COL729 course being taught by <a href=http://www.cse.iitd.ac.in/~sbansal>Sorav Bansal</a>. The course contents listed here are tentative and the exact material covered in the course may change as we go along.

<h2>Why study compiler optimization?</h2>
<p><b>How compiler optimizations are central to computer science</b>: Compilers
bridge the gap between what humans find it easy to understand and what machines
find easy to execute. There is perhaps no CS area that does not need this
important capability
in today's research scenario:
<ul>
<li>Domain specific languages for writing operating systems,
AI and machine learning algorithms, are very popular in the research
community</li>
<li>Gaps between safe languages (like Java/Python/OCaml) and
performant languages (like C/C++) depend on the power of the compilation
infrastructure</li>
<li>Efficiently harnessing the compute power of modern devices like
multi-core CPUs, GPUs, FPGAs, etc., is tightly dependent on compiler
support.</li>
</ul>
<i>My opinion</i>: Perhaps the most important innovations in the next decade in CS will
be based on compilation support.

<p><b>How it improves your understanding of computer science</b>:
Compilers is perhaps the only CS area that combines a rich knowledge of
logic, algorithms, theory, and low-level system programming, design and
performance optimization. Very commonly, logicians
derive research problems from real-world compiler problems; also, system
builders and researchers find some of the most intriguing and difficult
problems in compiler design.

<h2>Pre-requisites</h2>
This course will briefly sketch the fundamentals of <a href=http://www.cse.iitd.ac.in/~sbansal/col728>compiler design</a> and will quickly move to
the primary focus of the talk: compiler optimizations. We recommend that
you should have done a <a href=http://www.cse.iitd.ac.in/~sbansal/col728>compiler-design</a> course beforehand. However if you have not taken that
course but are very interested in taking this course, please write to me
with your CV/resume and I can guide you based on your background. You
should have at least done a UG course on logic and/or programming languages.

<p>The official pre-requisites are (see <a href=http://www.iitd.ac.in/sites/default/files/semsch/CouStudy_201819.pdf>courses of study</a>):
<ul>
<li>COL 216 : Computer Architecture</li>
<li>COL 226 : Programming Languages</li>
</ul>
or equivalent.

<h2>Course topics</h2>
Following are the tentative course topics; the exact topics will evolve as
we go along the course
<ul>
<li>Data-flow analyses : basic mathematical framework, examples like global constant propagation, liveness, reaching definitions, single static assignment, common subexpression elimination, alias analysis, lazy code motion, and perhaps some more.</li>
<li>Region-based analysis : natural loops, induction variable analysis, strength reduction based on induction variable analysis, auto-parallelization based on induction-variable analysis, reduction operations, and perhaps some more.</li>
<li>Inter-procedural analysis : inlining, inter-procedural data-flow analysis, function summaries, partial inlining.</li>
<li>Register allocation : graph-based techniques, enumerative techniques, performance studies</li>
<li>Peephole optimizations : examples from multiple architectures, superoptimization techniques to learn peephole optimizations (<a href=https://gmplib.org/~tege/gso-pldi92.pdf>GNU Superoptimizer</a>, <a href=https://www.cse.iitd.ernet.in/~sbansal/pubs/asplos06.pdf>Peephole Superoptimizer</a>).</li>
<li>Code synthesis and superoptimization : study some state-of-the-art superoptimizers and their pros and cons, e.g. <a href=https://www.embecosm.com/services/superoptimization/>Embecosm's GNU Superoptimizer 2.0</a>, <a href=https://www.embecosm.com/research/gso-2-0/>another effort by Embecosm</a>.</li>
<li>DSL-based non-bisimilar transformations : loop tiling, loop interchange, blocking</li>
<li>Polyhedral optimization framework, e.g., <a href=https://polly.llvm.org/>Polly</a>.</li>
<li>Empirical studies on compiler optimization</li>
</ul>

<h2>Lab assignments</h2>
We will have assignments primarily based on the LLVM IR to supplement the
course material. The assignment load is expected to be moderate.
