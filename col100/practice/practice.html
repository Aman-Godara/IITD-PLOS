<h2 id="practice-questions">Practice Questions</h2>
<!-- added by sorav -->
<ol style="list-style-type: decimal">
<li><strong>Big_O notation, Time Complexity of a Program</strong>: In this question, we will learn about the time complexity of passing arguments by value and by reference:</li>
</ol>
<ul>
<li>What is the time-complexity of the following program. Assume size of input queue is N</li>
</ul>
<pre><code>1  #include &lt;iostream&gt;
2  using namespace std;
3  int get_queue_length(Queue&lt;int&gt; const &amp;q)
4  {
5     return q.size();
6  }
7  int main()
8  {
9      cin &gt;&gt; n;   
10     Queue&lt;int&gt; q;
11     for (int i = 0; i &lt; n; i++) {
12         q.enqueue(i);
13     }
14     while (!q.isEmpty()) {
15         cout &lt;&lt; get_queue_length(q) &lt;&lt; endl;
16         cout &lt;&lt; q.dequeue() &lt;&lt; endl;
17     }
18     return 0;
19 }</code></pre>
<ul>
<li>Now what is the time complexity of the followng program (notice that the argument is now pass-by-value)</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dv">1</span>  <span class="er">#</span>include &lt;iostream&gt;
<span class="dv">2</span>  <span class="kw">using</span> <span class="kw">namespace</span> std;
<span class="dv">3</span>  <span class="dt">int</span> get_queue_length(Queue&lt;<span class="dt">int</span>&gt; q)
<span class="dv">4</span>  {
<span class="dv">5</span>     <span class="cf">return</span> q.size();
<span class="dv">6</span>  }
<span class="dv">7</span>  <span class="dt">int</span> main()
<span class="dv">8</span>  {
<span class="dv">9</span>      cin &gt;&gt; n;   
<span class="dv">10</span>     Queue&lt;<span class="dt">int</span>&gt; q;
<span class="dv">11</span>     <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
<span class="dv">12</span>         q.enqueue(i);
<span class="dv">13</span>     }
<span class="dv">14</span>     <span class="cf">while</span> (!q.isEmpty()) {
<span class="dv">15</span>         cout &lt;&lt; get_queue_length(q) &lt;&lt; endl;
<span class="dv">16</span>         cout &lt;&lt; q.dequeue() &lt;&lt; endl;
<span class="dv">17</span>     }
<span class="dv">18</span>     <span class="cf">return</span> <span class="dv">0</span>;
<span class="dv">19</span> }</code></pre></div>
<ul>
<li>And finally, what is the time complexity of the following program (notice that the argument is copied in a local variable before passing-by-reference)</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dv">1</span>  <span class="er">#</span>include &lt;iostream&gt;
<span class="dv">2</span>  <span class="kw">using</span> <span class="kw">namespace</span> std;
<span class="dv">3</span>  <span class="dt">int</span> get_queue_length(Queue&lt;<span class="dt">int</span>&gt; <span class="at">const</span> &amp;q)
<span class="dv">4</span>  {
<span class="dv">5</span>     <span class="cf">return</span> q.size();
<span class="dv">6</span>  }
<span class="dv">7</span>  <span class="dt">int</span> main()
<span class="dv">8</span>  {
<span class="dv">9</span>      cin &gt;&gt; n;   
<span class="dv">10</span>     Queue&lt;<span class="dt">int</span>&gt; q;
<span class="dv">11</span>     <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
<span class="dv">12</span>         q.enqueue(i);
<span class="dv">13</span>     }
<span class="dv">14</span>     <span class="cf">while</span> (!q.isEmpty()) {
<span class="dv">15</span>         Queue&lt;<span class="dt">int</span>&gt; q2 = q;
<span class="dv">16</span>         cout &lt;&lt; get_queue_length(q2) &lt;&lt; endl;
<span class="dv">17</span>         cout &lt;&lt; q.dequeue() &lt;&lt; endl;
<span class="dv">18</span>     }
<span class="dv">19</span>     <span class="cf">return</span> <span class="dv">0</span>;
<span class="dv">20</span> }</code></pre></div>
<!-- added by paras -->
<ol start="2" style="list-style-type: decimal">
<li><strong>Estimating the Output of a given program</strong>: In these questions, we will learn about how to analyze a simple program and produce the output for it.</li>
</ol>
<p><strong>2.1</strong> What is the output of the given program?</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dv">1</span>  <span class="er">#</span>include &lt;iostream&gt; 
<span class="dv">2</span>  <span class="kw">using</span> <span class="kw">namespace</span> std; 
<span class="dv">3</span>  
<span class="dv">4</span>  <span class="dt">int</span> main() 
<span class="dv">5</span>  { 
<span class="dv">6</span>    <span class="dt">int</span> a = <span class="dv">32</span>, *ptr = &amp;a; 
<span class="dv">7</span>    <span class="dt">char</span> ch = <span class="st">&#39;A&#39;</span>, &amp;cho = ch; 
<span class="dv">8</span>  
<span class="dv">9</span>    cho += a; 
<span class="dv">10</span>   *ptr += ch; 
<span class="dv">11</span>   cout &lt;&lt; a &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; ch &lt;&lt; endl; 
<span class="dv">12</span>   <span class="cf">return</span> <span class="dv">0</span>; 
<span class="dv">13</span>  } </code></pre></div>
<p><strong>2.2</strong> What will i and j equal after the code below is executed? Explain your answer.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> i = <span class="dv">5</span>;
<span class="dt">int</span> j = i++;</code></pre></div>
<!-- added by paras -->
<ol start="3" style="list-style-type: decimal">
<li><strong>Analyze the program</strong>: In these questions, one need to analyze the given piece of code at multiple levels.</li>
</ol>
<p><strong>3.1</strong> Is the program correct? If yes, what is the output of the given program? If not, what are the errors?</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dv">1</span> <span class="er">#</span>include &lt;iostream&gt; 
<span class="dv">2</span> <span class="kw">using</span> <span class="kw">namespace</span> std; 
<span class="dv">3</span>  
<span class="dv">4</span> <span class="dt">int</span> main() 
<span class="dv">5</span> { 
<span class="dv">6</span>    <span class="at">const</span> <span class="dt">int</span> i = <span class="dv">20</span>; 
<span class="dv">7</span>    <span class="at">const</span> <span class="dt">int</span>* <span class="at">const</span> ptr = &amp;i; 
<span class="dv">8</span>    (*ptr)++; 
<span class="dv">9</span>    <span class="dt">int</span> j = <span class="dv">15</span>; 
<span class="dv">10</span>   ptr = &amp;j; 
<span class="dv">11</span>   cout &lt;&lt; i; 
<span class="dv">12</span>   <span class="cf">return</span> <span class="dv">0</span>; 
<span class="dv">13</span> } </code></pre></div>
<p><strong>3.2</strong> Consider the two code snippets below for printing a vector. Is there any advantage of one vs. the other? Explain.</p>
<p>Option 1:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector vec;
<span class="co">/* ... .. ... */</span>
<span class="cf">for</span> (<span class="kw">auto</span> itr = vec.begin(); itr != vec.end(); itr++) {
    itr-&gt;print();
}</code></pre></div>
<p>Option 2:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector vec;
<span class="co">/* ... .. ... */</span>
<span class="cf">for</span> (<span class="kw">auto</span> itr = vec.begin(); itr != vec.end(); ++itr) {
    itr-&gt;print();
}</code></pre></div>
<!-- added by aman -->
<ol start="4" style="list-style-type: decimal">
<li><strong>Bitwise Operators</strong>: In this question we, will learn about some of the bitwise operators.</li>
</ol>
<ul>
<li>&amp; : Binary AND operator</li>
<li>| : Binary OR operator</li>
<li>^ : Binary XOR operator</li>
<li>&lt;&lt; : Binary Left shift operator</li>
<li>&gt;&gt; : Binary Right shift operator</li>
</ul>
<p>Read More at <a href="https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/" class="uri">https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/</a></p>
<p><strong>4.1</strong> Check if two numbers are equal without using arithmetic operators or comparison operators.</p>
<p><strong>4.2</strong> Divide an integer by 2^k and return the integer quotient. Do not use any arithmetic operator, loops or pow function.</p>
<p><code>cpp   int divide(int n, int k){     /* Do not use any arithmetic operators or loops or pow function */   }</code></p>
<p><strong>4.3</strong> Find the kth bit of an integer. Return 1 if it is 1 and 0 otherwise. You should not use any loop, or arithmetic operators. Complete the function below. Bit counting is done from the least significant bit and starts from 0. For example, for n = 19, its binary representation is 10011 the second bit is 0 while the first bit is 1 and the zeroth bit is 1.</p>
<p><code>cpp   int kthbit(int n, int k){     /* Do not use any loop or arithmetic operators */   }</code></p>
<p><strong>4.4</strong> Find if the number is a power of two, without using any other function call or loop. Complete the if condition below</p>
<p><code>cpp     int main(){       int n;       cin&gt;&gt;n;       if(/* ... */)         cout&lt;&lt;&quot;Number is power of 2&quot;&lt;&lt;endl;       else         cout&lt;&lt;&quot;Number is not a power of two&quot;&lt;&lt;endl;       return 0;     }</code></p>
<p><br> <!-- added by Ankesh --> <strong>5. Analysing an algorithm.</strong></p>
<p>Given below is a function/algorithm: <em>You'll enjoy foo!</em></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> foo(<span class="dt">int</span> a,<span class="dt">int</span> b)
{
  <span class="dt">int</span> ans=<span class="dv">1</span>;
  <span class="dt">int</span> temp=a;

  <span class="cf">while</span>(b)
  {
    <span class="cf">if</span>(b&amp;<span class="dv">1</span>)
      ans*=temp;
    temp*=temp;
    b/=<span class="dv">2</span>;
  }

  <span class="cf">return</span> ans;
}</code></pre></div>
<p><strong>5.1</strong> Predict the output for <strong>foo(3,5)</strong>.<br />
<strong>5.2</strong> What is <strong>foo(a,b)</strong> computing for general a,b&gt;=0, both integers.<br />
<strong>5.3</strong> What is time complexity of <strong>foo(a,b)</strong> for general a,b&gt;=0, both integers. You should report bigO complexity in terms of a and b.<br />
<strong>5.4</strong> Can you point out a problem with this code?<br />
(<strong>Spoiler:</strong> Will this code produce correct results for large a's and b's?)<br />
<strong>5.5</strong> How can you handle negative b?(Note: You can change <strong>function declaration</strong> to double <strong>foo(int a,int b)</strong>)<br />
<strong>5.6</strong> Will this logic/algorithm work if <strong>a</strong> were <strong>float</strong> instead of <strong>int</strong>.(Refer to code below)</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> foo(<span class="dt">double</span> a,<span class="dt">int</span> b)
{
  <span class="dt">double</span> ans=<span class="dv">1</span>;
  <span class="dt">double</span> temp=a;

  <span class="cf">while</span>(b)
  {
    <span class="cf">if</span>(b&amp;<span class="dv">1</span>)
      ans*=temp;
    temp*=temp;
    b/=<span class="dv">2</span>;
  }

  <span class="cf">return</span> ans;
}</code></pre></div>
<p><em>By now, I know you are tired of this foo function - just 1 more to go :p</em></p>
<p><strong>5.7</strong> This logic/algorithm won't work if <strong>b</strong> were <strong>float</strong> instead of <strong>int</strong>. Why?<br />
<strong>5.8</strong> <strong>Tough, can be skipped-</strong> Can you suggest some way to handle floating b? This will create a general power function.</p>
<p><em>End of chapter foo :)</em></p>
<!-- added by Sourabh -->
<p><strong>6.Recursion</strong></p>
<p>Recursion is a very powerful and an extremely useful tool. It is astonishing that with it's level of functionality,recursion is actually a very simple concept. Recursion formally defined as(source:<a href="https://en.wikipedia.org/wiki/Recursion">wiki/Recursion</a>)</p>
<ul>
<li>A class of objects or methods exhibit recursive behavior when they can be defined by two properties:</li>
</ul>
<ol style="list-style-type: decimal">
<li>A simple base case (or cases)—a terminating scenario that does not use recursion to produce an answer.</li>
<li>A set of rules that reduce all other cases toward the base case.</li>
</ol>
<p>Every recurive function has the following general format</p>
<pre><code>recfunc(params):
  if _BaseCondition_ :
    return _corresponding BaseResult_

  else :
    solve _corresponding subproblems_
    return result</code></pre>
<p>Now lets work out a example.</p>
<ul>
<li><strong>GCD(a,b)</strong></li>
<li>Base Condition: b=0 =&gt; GCD = a</li>
<li>Recurrence relation: GCD(a,b) = GCD(b,a%b)</li>
</ul>
<pre><code>int gcd(int a,int b) {
  int gcd_ab;

  if(b==0) {
    gcd_ab = a;
  } else {
    gcd_ab = gcd(b,a%b);
  }

  return gcd_ab;
}</code></pre>
<p>Try the following questions on your own. Identify the base condition and reccurence relation.</p>
<ol style="list-style-type: decimal">
<li><strong>Factorial</strong></li>
</ol>
<ul>
<li>Factorial of a non-negtaive integer <strong>n</strong> is denoted by <strong>n!</strong> or <strong>fact(n)</strong> and is defined as the product of all positive integers &lt;= <strong>n</strong>.</li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li><strong>Fibonnaci</strong></li>
</ol>
<ul>
<li>Fibonnaci sequence is a sequence of integers following the property that every number is the sum of two numbers preceding it.</li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li><strong>Tower of Hanoi</strong><br />
</li>
</ol>
<ul>
<li><p>The Tower of Hanoi is a mathematical game or puzzle. It consists of three rods and a number of disks of different sizes, which can slide onto any rod. The puzzle starts with the disks in a neat stack in ascending order of size on one rod, the smallest at the top, thus making a conical shape.(source:<a href="https://en.wikipedia.org/wiki/Tower_of_Hanoi">wiki/Tower_of_Hanoi</a>)</p></li>
<li>The objective of the puzzle is to move the entire stack to another rod, obeying the following simple rules:
<ol style="list-style-type: decimal">
<li>Only one disk can be moved at a time.</li>
<li>Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack or on an empty rod.</li>
<li>No disk may be placed on top of a smaller disk.</li>
</ol></li>
<li>The question is to print the sequence of moves which acheive the above objective for <strong>n</strong> disks and three towers named <strong>A,B,C</strong>. Every move should be in the format of <strong>move from T1 to T2</strong> where <strong>T1,T2</strong> are the names of the towers. All the disks are initially at Tower <strong>A</strong>. At the end of all the moves they should be at Tower <strong>B</strong>. Think of <strong>A</strong> as the starting tower, <strong>B</strong> as the final tower and <strong>C</strong> as the supporting tower.
<ul>
<li><strong>Hint1:</strong> Try identifying the simplest case which you can solve. Think in terms of number of disks.</li>
<li><strong>Hint2:</strong> Observe the fact that if you had the solution for movement from <strong>A</strong> to <strong>B</strong>. The same solution is applicable for movement from <strong>A</strong> to <strong>C</strong> by simply swapping <strong>B</strong> and <strong>C</strong> in every move.</li>
<li><strong>Hint3:</strong> What if you had the solution for <strong>n-1</strong> disks? Can you use that for the solution of n disks?</li>
</ul></li>
</ul>
