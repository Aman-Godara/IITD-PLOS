<h2>Recursion</h2>
We will learn a powerful algorithmic technique called <em>recursion</em>
<ul>
<li>Exploit self-similarity in problems</li>
<li>Learn recursive problem solving</li>
</ul>

We will spend several lectures on recursion -- don't worry if it does not make sense today. Your goal should be to do as many examples as possible.

<ul>
<li><b>recursion</b>: The function definition involving a call to the same function
<ul>
<li>Solving a problem using recurstion depends on solving smaller (simpler) occurrences of the same problem until the problem is simple enough that you can solve it directly.</li>
<li>Key question: "<em>How is this problem self-similar?</em>" --- what are the smaller subproblems that make up the bigger problem?
</ul>
</li>
<li>Occurs in many places in code and in real world
<ul>
<li>Looking up a word in dictionary may involve looking up other words (that occur in the meaning of the first word)</li>
<li>Nested structures, e.g., trees, file folders, collections, can be self similar</li>
<li>Patterns can contain smaller versions of the same pattern (fractals) </li>
</ul>
</li>
</ul>

<p><b>recursive programming</b>: Writing 
<u>functions that call themselves</u> to 
solve problems that are recursive in nature. 
<ul>
<li> An equally powerful substitute for  iteration
 (loops).</li>
<li>Particularly well-suited to solving certain types of problems </li>
<li>Leads to 
elegant
, simplistic, short code (when used well)</li>
<li>Many programming languages (
"functional" languages
 such as 
Scheme, ML, and Haskell) use recursion exclusively  (no loops)</li>
</ul>

<p>Recursive blue shirt
<ul>
<li>We want to count the number of people in the room who are wearing a blue shirt</li>
<li>We can't directly count (there are a lot of people in the room)</li>
<li>But all of you can help</li>
<li>You can ask questions of the person behind you and respond to the questions of the person in front of you</li>
</ul>
<em>How can we solve this recursively?</em>

<p>The first person looks behind them:
<ul>
<li>If there is no one there, the person responds with 1 if he/she is wearing a blue shirt or 0 if he/she is not.</li>
<li>If there is someone behind the person, <em>ask them how many people behind them (including the answerer) are wearing a blue shirt</em> (<b>recursive call</b>)</li>
<li>Once the person receives a response, they add 1 if he/she is wearing a blue shirt, or 0 if he/she is not, and respond to the person in front of them.</li>
<li>Now I (the instructor) needs to ask everyone in the front row --- much simpler!</li>
</ul>

<p>Recursion and cases: Every recursive algorithm involves at least two cases:
<ul>
<li> <b>base case</b>: A simple occurrence that can be answered directly.</li>
<li><b>recursive case</b>: A more complex occurrence of the problem that cannot be directly answered, but can be instead described in terms of smaller occurrences of the same problem</li>
</ul>

<p>Key idea: In a recursive piece of code, you handle a small part of the 
overall task yourself (usually the work involves modifying the results of 
the smaller problems), then make a recursive call to handle the rest.

<p>Ask yourself, "how is ths task <b>self-similar</b>?"
<ul>
<li>"How can I describe this algorithm in terms of a smaller or simpler version of itself?"</li>
</ul>

<p>Recursion Tips
<ul>
<li>Look for <em>self-similarity</em></li>
<li>Find the minimum <em>amount of work</em></li>
<li>Make the problem <em>simpler</em> by doing the least amount of work possible.</li>
<li><em>Trust</em> the recursion</li>
<li>Find a stopping point (<em>base case</em>)</li>
</ul>

<p>Three rules of recursion
<ul>
<li>Every (valid) input must have a case (either recursive or base)</li>
<li>There <b>must</b> be a base case that makes not recursive calls, i.e., on some input(s), the code should not make any recursive calls</li>
<li>The recursive case must make the problem simpler and make forward progress to the base case. e.g., if the person behind you asks the person in front of him/her, that is not going to make progress</li>
</ul>

<p>Recursive Program structure
<pre>
recursiveFunc ()
{ 
  if (test for simple case) { // base case 
    Compute the solution without recursion 
  } else { // recursive case
    1. Break the problem into  subproblems of the same form 
    2. Call  recursiveFunc() on each  self-similar  subproblem
    3. Reassamble the results of the subproblems
  } 
} 
</pre>

<p>Non-recursive factorial
<pre>
// Returns n!, or 1 * 2 * 3 * 4 * ... * n. 
// Assumes n >= 1. 
int factorial(int n) { 
    int total = 1; 
    for (int i = 1; i <= n; i++) { 
        total *= i; 
    } 
    return total; 
} 
</pre>
Important observations:
<pre>
0!= 1! = 1
4! = 4 * 3 * 2 * 1
5! = 5 * (4 * 3 * 2 * 1) = 5 * 4!
</pre>

<p>Recursive factorial
<pre>
// Returns n!, or 1 * 2 * 3 * 4 * ... * n. 
// Assumes n >= 0. 
int factorial(int n) { 
    if (n <= 1) {
        // base case 
        return 1; 
    } else { 
        return n * factorial(n - 1);
        // recursive case 
    } 
} 
</pre>
<ul>
<li>The recursive code handles a small part of the overall task (by multiplying by <code>n</code>), then makes a recursive call to handle the rest
<ul>
<li>The recursive version is written <u>without using any loops</u>
<ul>
<li>Recursion <em>replaces</em> the while loop</li>
</ul>
</li>
<li>We separate the code into a <em>base case</em> (a simple case that does not make any recursive calls), and a <em>recursive case</em>.</li>
</ul>
</li>
</ul>

<p>Recursive stack trace: Show the chain of function calls represented through a stack for <code>fact(4)</code>

<p>Consider the following recursive function:
<pre>
int mystery(int n) { 
    if (n < 10) { 
        return n; 
    } else { 
        int a = n / 10; 
        int b = n % 10; 
        return mystery(a + b); 
    }
} 
</pre>
What is the result of <code>mystery(648)</code>? (answer: 9)

<p>isPalindrome exercise: write a recursive function <code>isPalindrome</code> that accepts a string and returns true if it reads the same forwards as backwards.
<pre>
isPalindrome("madam") returns true
isPalindrome("racecar") returns true
isPalindrome("step on no pets") returns true
isPalindrome("able was I ere I saw elba") returns true
isPalindrome("Q") returns true
isPalindrome("Java") returns false
isPalindrome("rotater") returns false
isPalindrome("byebye") returns false
isPalindrome("notion") returns false
</pre>
<ul>
<li>How is this problem <em>self-similar></em>?</li>
<li>What is the minimum amount of work?</li>
<li>How can we make the problem simpler by doing the minimum amount of work?</li>
<li>What is our stopping point, <b>base case</b>?</li>
</ul>

<h3>Recursive Big-O</h3>
<ul>
<li>Below is the "pseudocode" for finding BigO of a function
<ul>
<li>Note that this is not real code; this is to show the recursive nature of BigO</li>
<li>Self-similarity: find BigO of smaller code blocks and combine them</li>
<li>The BigO pseudocode does not cover function calls and some other cases (to keep the discussion simple) --- though experiment to expand this</li>
</ul>
</li>
</ul>
<pre>
findBigO(codeSnippet):
  if codeSnippet is a single statement:
    return O(1)
  if codeSnippet is a loop:
    return number_of_times_loop_runs * findBigO(loop_inside)
  for codeBlock in codeSnippet:
    return the_sum_of findBigO(codeBlock)
</pre>
What are the subproblems? loop_inside and codeBlock.
<br>How are the results of subproblems combined? Using "number_of_times_loop_runs" and "the_sum_of"
<br>Where are the recursive calls? calls to findBigO(loop_inside) and findBigO(codeBlock)
<br>What is the base case? single statement
<br>Are we following the 3 rules of recursion? e.g., are we moving towards the base case in the recursive call?

<p>Example: compute bigO for the following code using this recursive pseudocode:
<pre>
for (int i = 0; i < N * N; i += 3) {
  for (int j = 3; j <= 219; j++) {
    cout << "sum: " << i + j << endl;
  }
}
cout << "Enjoy COL100\n";
</pre>
Show the working of findBigO on this code snippet.

<p>Exercise: Write a function <code>power</code> that accepts integer parameters for a base and exponent and computes <code>base ^ exponent</code>.
<ul>
<li>First write code using for-loop</li>
<li>Now write a <u>recursive</u> version of this function (one that calls itself)</li>
<li>Solve the problem <u>without using any loops</u>.
</ul>

<p>Method:
<ul>
<li>How is the problem self-similar? x^n = x * x^(n-1)</li>
<li>What is the minimum amount of work? multiplication</li>
<li>How can we make the problem simpler by doing the least amount of work?</li>
<li>What is our stopping point (base case)? n = 0. Why not n=1?</li>
</ul>

<pre>
//Assumes exp >= 0
int power(int base, int exp)
{
  if (exp == 0) {
    return 1;
  } else {
    return base * power(base, exp - 1);
  }
}
</pre>
Show the execution of power(5, 3);

<p>Can we do better? Notice that x^18 = (x*x)^9; x^9=x*x^8
<pre>
//Assumes exp >= 0
int power(int base, int exp)
{
  if (exp == 0) {
    return 1;
  } else if (exp % 2 == 0) {
    return power(base * base, exp/2); //recursive case 1
  } else {
    return base * power(base, exp - 1); //recursive case 2
  }
}
</pre>
